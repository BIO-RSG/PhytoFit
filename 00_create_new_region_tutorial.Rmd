---
title: "How to create a new region for PhytoFit"
output:
  html_document:
    toc: true
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(oceancolouR)
library(fst)
library(dplyr)
library(raster)
library(ggplot2)
library(patchwork)
filename = "data/testregion/testregion_modis_ocx_2015.fst"
```

This tutorial contains instructions to create your own region for use in the PhytoFit app.  

Before you can begin, make sure you have the required library:  

```{r}
library(fst)
```


# STEP 1: Naming scheme for region, sensor, variable

Decide on the abbreviations you will use for your region, as well as the sensor(s) and variable(s).  
* Abbreviations should only contain **letters** and **numbers** (**no** underscores, dashes, spaces, or other special characters).  

For example, for MODIS-Aqua OCx chlorophyll-a in the Atlantic, the following abbreviations are used:  

- region = *atlantic*  
- sensor = *modis*  
- variable = *ocx*  

Open `00_input_variables.R` and check the "VARIABLES THAT CAN BE CHANGED" section near the top to add your sensor and variable names and abbreviations, **if they are not already present**. Using the example above, you would need to make sure that *sensor_names* and *variable_names* contained the following values:  

```{r}
sensor_names <- c("modis" = "MODIS-Aqua")
variable_names <- c("ocx" = "OCx chl-a (global, band ratio)")
```

**IMPORTANT:** Note that the vector names (i.e. *modis* and *ocx* in this example) **must** match the sensor and variable names in your data filenames (e.g. `r filename`), described in STEP 2 below.  

<br>

# STEP 2: Data files  

Create data files for your new region.  

1. Download daily satellite data for your region. Each file must exist on the same grid (i.e. the latitude/longitude vectors or grids must be identical for each daily file, so that the data files can be stored together and a single copy of the navigational data can be stored separately). **Satellite data and the latitude and longitude vectors must all be the same length and in the same order.**  
Note that if your data is on a regular 2D grid and you have a single vector of latitudes for the y-axis and longitudes for the x-axis, you will need to flatten the 2D grid and repeat the latitude and longitude vectors until they are each the same length as the flattened grid, e.g.:  

```{r}
example_data <- matrix(letters[1:12], nrow=4)
example_lats <- 1:4
example_lons <- 1:3

new_lats <- rep(example_lats, 3) # 3 times, one for each column
new_lons <- rep(example_lons, 4) # 4 times, one for each row
new_data <- c(example_data) # flatten data grid

data.frame(data = new_data, latitudes = new_lats, longitudes = new_lons, stringsAsFactors = FALSE)
```

2. Combine all daily data for a given year into a single numeric matrix, where row = pixel and column = day of year. **IMPORTANT:** Missing days should be included as a column of NA values at the appropriate column index (e.g. if you don't have data in your region on day 36, then column 36 should be all NA). Note that day 366 of a leap year is ignored/removed in the app.  

Taking an example chl-a matrix from *L3b 2015 MODIS-Aqua OCx chlorophyll-a*:  

```{r}
load("testregion.rda")
str(testregion_chl)
```

3. Flatten the matrix into a dataframe. Note that pixels with missing data are retained here so that it can be quickly reshaped into the pixel / day of year matrix for easier and faster subsetting. The data is saved in this flattened format instead of as a matrix because the file size is smaller and faster to read.  

```{r}
df = data.frame(var = as.numeric(testregion_chl), stringsAsFactors = FALSE)
```

4. Write the dataframe to an *fst* file and store it in the `data/region/` subfolders following the filenaming scheme `data/region/region_sensor_variable_year.fst`. Replace "region", "sensor", "variable", and "year" with the appropriate values (see example below).  

```{r}
filename = "data/testregion/testregion_modis_ocx_2015.fst"
write_fst(df, path=filename, compress=100)
```

<br>


# STEP 3: More region info in 00_create_new_region.R  

Open `00_create_new_region.R` -- This script can be used to define the parameters of your region.  

Add your region abbreviation (e.g. `testregion`) to the `reg_list` variable near the top of the script (optional: remove any regions in that list that you don't want to include, for example if you're missing the files used to create the latitude/longitude vectors).  

```{r}
reg_list <- c("atlantic", "pacific", "gosl1km", "gosl4km", "baffin", "testregion")
```


Update **SECTION 1** (metadata, latitude and longitude vectors) and **SECTION 2** (polygon definitions):  

### SECTION 1: Metadata, latitudes, longitudes  

**WARNING:**  
*It's recommended your region be < 300,000 pixels so it doesn't overload your computer memory when you load the data in the app, but this can be adjusted depending on your situation.*  

Enclose your region metadata, latitude, and longitude vector definitions in an `if` statement (see example below) so you can omit it at any point by simply removing the region abbreviation from `reg_list`.  

```{r}

reginfo <- list()

if ("testregion" %in% reg_list) {
  # Define your latitude and longitude vectors. Here we'll use the latitude and longitude vectors associated with the chl-a
  # matrix stored in testregion.rda, which was loaded in STEP 2. Add them to the reginfo list with other metadata:
  reginfo$testregion = list(name = "My test region",
                            lat = as.numeric(testregion_lat), # make sure the final lat/lon vectors are numeric
                            lon = as.numeric(testregion_lon),
                            data_resolution = 4.64^2,
                            map_resolution = c(0.07,0.04167),
                            center_lon = -56,
                            center_lat = 47,
                            zoom_level = 5)
}

```

- **name:** The full name of the region (this appears in the drop-down menu of the app)  
- **lat:** The numeric vector of latitudes for the region  
- **lon:** The numeric vector of longitudes for the region  
- **data_resolution:** Satellite data resolution, numeric value in km<sup>2</sup>  
- **map_resolution:** Numeric vector of two values, (longitude_resolution, latitude_resolution) in decimal degrees for the raster image on the map. See below for more details.  
- **center_lon:** The longitude at the center of the map when it first loads
- **center_lat:** The latitude at the center of the map when it first loads
- **zoom_level:** The zoom level of the map when it first loads

**Notes about lat/lon vectors:**  

lat/lon vectors must be the same length, and in the same order as the data vector (so each pixel has a variable/lat/lon set). Values are in decimal degrees, and west/south longitudes/latitudes should be negative.  

**Notes about map_resolution:**  

In the app, statistics and bloom fits are calculated using the input data points, but the map is created by projecting the points onto a raster with a regular grid because it requires less memory and loads faster. This does not affect the calculations, it is only used for viewing the satellite image. When rasterizing the points for the map, overlapping points are combined using a mean. The grid resolution is defined by map_resolution, and smaller values = higher resolution. Below is an example using day 134 of daily L3b MODIS-Aqua OCx chlorophyll-a from 2015 to show the differences between the original plotted points and rasterized points with different map_resolutions, showing the importance of selecting a map_resolution that is not too small or too big.  

The optimal map_resolution will depend on your satellite data resolution and the range of latitudes used in your region. Leaflet (the package used for the map) uses the [Web Mercator Projection](https://spatialreference.org/ref/sr-org/45/), so higher latitudes will be stretched more horizontally and you would therefore want a lower resolution (i.e. larger values in map_resolution) to fill the gaps (note that for the "baffin" region, longitude resolution is set to 0.2, whereas for "gosl4km", it's set to 0.07).  

**Top left:** Binned points plotted on the map.  
**Top right:** Rasterized points with a map_resolution that gives the best approximation of the original points.  
**Bottom left:** Rasterized points with a map_resolution that is too high, resulting in gaps in the raster grid.  
**Bottom right:** Rasterized points with a map_resolution that is too low, losing the higher-resolution detail in the original points.  

```{r fig.width=10, fig.height=6.5, echo=FALSE}

# Pick a day of year to plot as an example
day <- 134

# Get a vector of pixel indices that contain valid chl on this day
valid_ind <- !is.na(testregion_chl[,day]) & is.finite(testregion_chl[,day])

# Combine lat/lon/chl in a dataframe
# (Note that we're logging chl to make it easier to see)
pts <- data.frame(lon = testregion_lon[valid_ind],
                  lat = testregion_lat[valid_ind],
                  chl = log10(testregion_chl[valid_ind, day]),
                  stringsAsFactors = FALSE) %>%
  dplyr::mutate(chl = set_limits(chl, lower=-0.5, upper=2))

# Map the points
worldmap <- ggplot2::map_data("world")
cm <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))(100)
col_limits <- c(-0.5,2)
map1 <- ggplot() +
  geom_map(data = worldmap, map = worldmap, aes(x = long, 
            y = lat, group = group, map_id = region), fill = "white", 
            colour = "#7f7f7f", size = 0.5, alpha = 0.8) +
  geom_point(data=pts, aes(x=lon, y=lat, color=chl)) +
  scale_x_continuous(limits=range(pts$lon), expand=c(0,0)) +
  scale_y_continuous(limits=range(pts$lat), expand=c(0,0)) +
  theme_bw() +
  ggtitle("Points") +
  theme(axis.title=element_blank(),
        legend.title=element_blank(),
        legend.margin = margin(0, 0, 0, 0),
        legend.box.margin = margin(-10, 0, -10, -10),
        plot.title = element_text(hjust = 0.5)) +
  guides(color = guide_colorbar(ticks.colour = "black")) +
  scale_color_gradientn(colours = cm, na.value = "transparent", limits=col_limits)

# Rasterize and map
mres <- reginfo$testregion$map_resolution
tr <- rasterFromXYZ(pts, res=mres, digits=0)
crs(tr) <- "+proj=longlat +datum=WGS84 +no_defs"
map2 <- make_raster_map(tr, xlim=range(pts$lon), ylim=range(pts$lat), title=paste0("Raster ( map_resolution = c(",mres[1],", ",mres[2],") )"), col_limits=col_limits, set_extremes=TRUE)

# Rasterize again with a different map_resolution - gappy
mres <- c(0.04,0.02)
tr <- rasterFromXYZ(pts, res=mres, digits=0)
crs(tr) <- "+proj=longlat +datum=WGS84 +no_defs"
map3 <- make_raster_map(tr, xlim=range(pts$lon), ylim=range(pts$lat), title=paste0("Gappy raster ( map_resolution = c(",mres[1],", ",mres[2],") )"), col_limits=col_limits, set_extremes=TRUE)

# Rasterize again with a different map_resolution - pixelated
mres <- c(0.1,0.08)
tr <- rasterFromXYZ(pts, res=mres, digits=0)
crs(tr) <- "+proj=longlat +datum=WGS84 +no_defs"
map4 <- make_raster_map(tr, xlim=range(pts$lon), ylim=range(pts$lat), title=paste0("Pixelated raster ( map_resolution = c(",mres[1],", ",mres[2],") )"), col_limits=col_limits, set_extremes=TRUE)

# Use patchwork library to combine maps into a grid
(map1 + map2) / (map3 + map4) + plot_layout(guides="collect")

```


### SECTION 2: Polygons  

Make the polygons to be plotted on your map.  
**Note 1:** If you don't want any polygons, just create an empty list, e.g.: `poly$testregion = list()`  
**Note 2:** This should *not* be enclosed in an "if" statement, unlike the code in SECTION 1.  


```{r}
poly <- list()
# Example using boxes from the atlantic region
poly$testregion = list("AC"=list(name = "Avalon Channel (AC)",
                                 label = "AC",
                                 lat = c(46, 48, 48, 46, 46),
                                 lon = c(-53, -53, -51.5, -51.5, -53)),
                       "CS_V01"=list(name = "Cabot Strait (CS) V01",
                                     label = "CS",
                                     lat = c(46.9, 48, 48, 46.9, 46.9),
                                     lon = c(-60.4, -60.4, -59, -59, -60.4)),
                       "CS_V02"=list(name = "Cabot Strait (CS) V02",
                                     label = NA,
                                     lat = c(47, 47.758, 48, 48, 47.436, 47),
                                     lon = c(-59.903, -60.73, -60.322, -59.783, -59.168, -59.903)))
```

- **poly_ID:** The name of a list element for your region, e.g. *AC*, *CS_V01*, or *CS_V02* in the above example. This must be unique to each polygon. If there are multiple versions of a polygon, use something like poly_v01, poly_v02, etc.  
- **name:** The full name of the polygon, which appears in the polygon drop-down menu.  
- **label:** The label that appears next to the polygon on the map. Set to NA for no label. If you have multiple overlapping versions of a polygon, you could set the label on the first one and set the others to NA, as in the above example.  
- **lat:** Numeric vector of latitudes of the polygon vertices, starting and ending with the same point.  
- **lon:** Corresponding numeric vector of longitudes of the polygon vertices, so that each vertex has a lat/lon pair.  

**WARNING:** NA values are not allowed in the polygon lats/lons (polygons must be continuous, not split into multiple sub-polygons).  

The example polygons above would be plotted like this:  

```{r echo=FALSE, fig.width=6, fig.height=4}

# Rasterize and map
mres <- reginfo$testregion$map_resolution
tr <- rasterFromXYZ(pts, res=mres, digits=0)
crs(tr) <- "+proj=longlat +datum=WGS84 +no_defs"
map_poly <- make_raster_map(tr, xlim=range(pts$lon), ylim=range(pts$lat), col_limits=col_limits, set_extremes=TRUE)

# Add polygons
poly_coord_list <- lapply(poly$testregion, function(y) y[c("lat","lon")])
poly_names <- names(poly_coord_list)
original_polys <- lapply(1:length(poly_coord_list), function(k) {Polygon(coords=cbind(poly_coord_list[[k]]$lon, poly_coord_list[[k]]$lat), hole=TRUE)})
original_polyIDs <- lapply(1:length(original_polys), function(k) {Polygons(list(original_polys[[k]]), toupper(poly_names[k]))})
poly_coord_list <- SpatialPolygons(original_polyIDs, 1:length(poly_coord_list))
centroids <- lapply(poly$testregion, function(y) data.frame(label=y$label,lat=mean(y$lat),lon=mean(y$lon))) %>% do.call(what=rbind)
map_poly <- map_poly +
  geom_polygon(data=poly_coord_list, aes(x=long, y=lat, group=id), fill=NA, color="black", size=1.5, alpha=0.6) +
  geom_label(data=centroids, aes(x=lon, y=lat, label=label))

map_poly

```


### Finish defining your region  

After adding the metadata, latitude, longitude, and polygons to `00_create_new_region.R`, run the script to save your region metadata to `reginfo.rds`, which can be read into PhytoFit later.  

<br>

You're done! Now load the app and your new region should be available in the drop-down menu.  

<br><br>
